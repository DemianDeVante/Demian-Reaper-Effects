/* Generated by: https://www.npmjs.com/package/jsfx-preprocessor */
desc:D Ugly Pitch
in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:correction_semitones_global=0<-12,12,1>-transpose (semitones)
slider2:tonality_limit=0.2<0,1,0.01>-tonality limit
slider3:formant_shift_semitones=0<-12,12,0.1>-formant shift (semitones)

import ui-lib.jsfx-inc
filename:0,themes/bitmap-simple/theme-cyan.png
needs_slider_update

import ui-lib.jsfx-inc
import pitch-detection.jsfx-inc
import delay-utils.jsfx-inc

@init

	freemem = ui_setup(1000000);

	// OVERFLOW PROTECTION - if you get an overflow, increase this value.
	safe_allocation = 65536*4;

	!not_first_init ? (
		reset_shift = 0;
		display_follow_playback = 1;
		not_first_init = 1;
	);

	freemem = 0;
	freemem = ui_setup(freemem);
	freemem = pitch_detection.pitch_detection_init(freemem);
	pitch_detection.pitch_detection_config_tonality_limit(0);
	latencysamples = pitch_detection.pitch_detection_delay();
	min_freq = 10;
	max_delay = srate/min_freq;
	freemem = delay0.delay_init(freemem, latencysamples + max_delay);
	freemem = delay1.delay_init(freemem, latencysamples + max_delay);

	formant_max_window_length = ceil(0.1*srate);
	formant_remaining = formant_max_window_length;
	formant_buffer_length = formant_max_window_length;
	formant_input_original = freemem;
	freemem += formant_buffer_length*2;
	formant_input_shifted = freemem;
	freemem += formant_buffer_length*2;
	formant_output = freemem;
	freemem += formant_buffer_length*2;
	formant_fftsize = pow(2, ceil(log(formant_max_window_length + 1)/log(2)));
	formant_fftbuffer = freemem = 65536*ceil(freemem/65536);
	freemem += formant_fftsize*2;
	formant_spectrum_original = freemem;
	freemem += formant_fftsize*0.5;
	formant_spectrum_shifted = freemem;
	freemem += formant_fftsize*0.5;
	formant_index = 0;

	analysis = safe_allocation;
	analysis_step = 4/*ANALYSIS: */;
	!analysis_interval ? analysis_interval = 0.01; // 10ms
	//analysis_count = 0;

	freemem > analysis ? (
		ui_error("Overflow! Increase \"safe_allocation\" in the code, and email Geraint: luffgd@gmail.com");
	);

@block

	block_index = 0;

	// Stop the pre-processor complaining: 2/*SHIFT_MODE: PLAIN, PLAIN_WITH_FORMANTS*/
	!shift_mode ? (
		shift_mode = 1/*SHIFT_MODE:PLAIN*/;
	);

	correct_formants_ugly = 0;
	shift_mode == 1/*SHIFT_MODE:PLAIN_WITH_FORMANTS*/ ? (
		correct_formants_ugly = 1;
	);

	pdc_delay = latencysamples
		+ (correct_formants_ugly ? formant_buffer_length : 0);
	pdc_bot_ch = 0;
	pdc_top_ch = 2;

@sample

	seconds = play_position + block_index/srate;

	// Pitch-detection for shifting and analysis
	pitch_detection.pitch_detection_input(spl0, spl1);

	// Shifting
	index_float = seconds/analysis_interval;
	index_int = floor(index_float);
	index_ratio = index_float - index_int;
	entry = analysis + index_int*analysis_step;
	entrynext = entry + analysis_step;
	correction_semitones = entry[3/*ANALYSIS:SHIFT_SEMITONES*/]*(1 - index_ratio) + entrynext[3/*ANALYSIS:SHIFT_SEMITONES*/]*index_ratio + correction_semitones_global;
	index_int >= analysis_count || reset_shift ? (
		correction_semitones = correction_semitones_global;
	);

	//formant_shift_semitones = 0;
	formant_shift_factor = pow(2, formant_shift_semitones/12);

	freq = pitch_detection.pitch_detection_freq();
	tonality = pitch_detection.pitch_detection_tonality();
	tonality < tonality_limit ? (
		correction_semitones *= tonality/tonality_limit;
	);

	wavelength = srate/max(min_freq, freq);
	correction_factor = pow(2, correction_semitones/12);
	correction_freq = freq*(correction_factor - 1);
	freq > min_freq && abs(correction_freq) > 1 ? (
		phase += correction_freq/srate;
	) : phase > 0.001 ? (
		// Slew towards 1
		phase += (1 - phase)*max(correction_freq, 1)/srate;
	);
	while (phase > 1) (
		phase -= 1;
	);
	while (phase < 0) (
		phase += 1;
	);

	// Implement cross-fading delay
	delay0.delay_input(spl0);
	delay1.delay_input(spl1);
	delayA = latencysamples - phase*wavelength;
	delayB = delayA + wavelength;

	formant_input_original[2*formant_index] = delay0.delay_output_linear(latencysamples);
	formant_input_original[2*formant_index + 1] = delay1.delay_output_linear(latencysamples);

	// Cubic fade between the two
	phase_factor = phase*phase*(3 - 2*phase);

	spl0 = delay0.delay_output_linear(delayA)*(1 - phase_factor) + delay0.delay_output_linear(delayB)*phase_factor;
	spl1 = delay1.delay_output_linear(delayA)*(1 - phase_factor) + delay1.delay_output_linear(delayB)*phase_factor;

	formant_input_shifted[2*formant_index] = spl0;
	formant_input_shifted[2*formant_index + 1] = spl1;

	analysis_index_ratio = floor(seconds/analysis_interval);
	analysis_index = floor(analysis_index_ratio);
	analysis_index_ratio -= analysis_index;
	(analysis_index == analysis_index_prev + 1)? (
		// Add clean entries to the analysis table
		while (analysis_count < analysis_index + 1) (
			analysis_entry = analysis + analysis_step*analysis_count;
			analysis_entry[0/*ANALYSIS:INPUT_FREQ*/] = analysis_entry[1/*ANALYSIS:INPUT_AMP*/] = analysis_entry[2/*ANALYSIS:INPUT_TONALITY*/] = analysis_entry[3/*ANALYSIS:SHIFT_SEMITONES*/] = 0;
			analysis_count += 1;

			// Stretch view if we're adding more
			display_left_time = min(display_left_time, seconds);
			display_right_time = max(display_right_time, seconds);
		);
		analysis_entry = analysis + analysis_step*analysis_index;
		analysis_entry[0/*ANALYSIS:INPUT_FREQ*/] = pitch_detection.pitch_detection_freq();
		analysis_entry[1/*ANALYSIS:INPUT_AMP*/] = pitch_detection.pitch_detection_amp();
		analysis_entry[2/*ANALYSIS:INPUT_TONALITY*/] = pitch_detection.pitch_detection_tonality();

		reset_shift ? (
			analysis_entry[3/*ANALYSIS:SHIFT_SEMITONES*/] = 0;
		);
	) : (analysis_index != analysis_index_prev) ? (
		reset_shift = 0;
	);

	(play_state&1) ? block_index += 1;
	analysis_index_prev = analysis_index;

	formant_index += 1;
	formant_index >= formant_buffer_length ? (
		formant_index = 0;
	);

	function calculate_spectrum(buffer, fftsize, spectrum, resolution) local(i, i2, sum, blurspan, mag2) (
		spectrum[0] = buffer[0]*buffer[0] + buffer[1]*buffer[1];
		i = 1;
		while (i < fftsize*0.5) (
			i2 = fftsize - i;
			mag2 = buffer[2*i]*buffer[2*i] + buffer[2*i + 1]*buffer[2*i + 1] + buffer[2*i2]*buffer[2*i2] + buffer[2*i2 + 1]*buffer[2*i2 + 1];
			spectrum[i] = mag2;
			i += 1;
		);

		blurspan = floor(fftsize*resolution/srate + 0.75);
		sum = 0;
		i = 0;
		while (i < fftsize*0.5) (
			sum += spectrum[i];
			spectrum[i] = sum;
			i += 1;
		);
		i = fftsize*0.5 - 1;
		while (i > blurspan) (
			spectrum[i] = (spectrum[i] - spectrum[i - blurspan])/blurspan;
			i -= 1;
		);
		while (i >= 0) (
			spectrum[i] = spectrum[i]/(i + 1);
			i -= 1;
		);

		blurspan = floor(fftsize*resolution/srate + 0.25);
		sum = 0;
		i = fftsize*0.5 - 1;
		while (i >= 0) (
			sum += spectrum[i];
			spectrum[i] = sum;
			i -= 1;
		);
		i = 0;
		while (i < fftsize*0.5 - blurspan) (
			spectrum[i] = (spectrum[i + blurspan] - spectrum[i])/blurspan;
			i += 1;
		);
		while (i < fftsize*0.5) (
			spectrum[i] = spectrum[i]/(fftsize*0.5 - i);
			i += 1;
		);
		i = 0;
		while (i < fftsize*0.5) (
			spectrum[i] = sqrt(spectrum[i]);
			i += 1;
		);
	);

	function move_from_input_to_buffer(fftsize, window_length, input, spectrum, resolution) (
		i = 0;
		centre_index = max(formant_max_window_length*0.5, formant_max_window_length - window_length*0.75);
		centre_index = formant_buffer_length*0.5;
		while (i < fftsize) (
			window_ratio = (i - centre_index)/window_length;
			window_ratio < 0.5 ? (

				i2 = formant_index + i;
				i2 >= formant_buffer_length ? (
					i2 -= formant_buffer_length;
				);

				window_value = (window_ratio < 0) ? 1 : 0.5 + 0.5*cos(window_ratio*2*$pi);

				// Move from input to fft buffer
				formant_fftbuffer[2*i] = input[2*i2]*window_value;
				formant_fftbuffer[2*i + 1] = input[2*i2 + 1]*window_value;

				input[2*i2] *= (1 - window_value);
				input[2*i2 + 1] *= (1 - window_value);
			) : (
				formant_fftbuffer[2*i] = formant_fftbuffer[2*i + 1] = 0;
			);
			i += 1;
		);

		// TODO: maybe we don't always need an FFT this big - could pass in FFT size to this function
		fft(formant_fftbuffer, fftsize);
		fft_permute(formant_fftbuffer, fftsize);
		calculate_spectrum(formant_fftbuffer, fftsize, spectrum, resolution);
	);

	correct_formants_ugly ? (
		formant_remaining -= 1;
		formant_remaining <= 0 ? (
			//window_length = max(ceil(0.01*srate), min(formant_max_window_length, wavelength*10));
			window_length = formant_max_window_length*0.75;
			//fftsize = min(formant_fftsize, pow(2, ceil(log(window_length*2)/log(2))));
			fftsize = formant_fftsize;
			formant_remaining += window_length*0.5;

			resolution = max(max(freq, freq + correction_freq), min_freq);
			move_from_input_to_buffer(fftsize, window_length, formant_input_original, formant_spectrum_original, resolution);
			move_from_input_to_buffer(fftsize, window_length, formant_input_shifted, formant_spectrum_shifted, resolution);

			factor = (formant_spectrum_original[0]/formant_spectrum_shifted[0])/fftsize/formant_shift_factor;
			formant_fftbuffer[0] *= factor;
			formant_fftbuffer[1] *= factor;

			formant_fftbuffer[fftsize] = 0;
			formant_fftbuffer[fftsize + 1] = 0;
			i = 1;
			while (i < fftsize*0.5) (
				i2 = fftsize - i;
				i_formant = min(fftsize*0.5 - 1, floor(i/formant_shift_factor + 0.5));
				factor = (formant_spectrum_original[i_formant]/formant_spectrum_shifted[i])/fftsize/formant_shift_factor;
				formant_fftbuffer[2*i] *= factor;
				formant_fftbuffer[2*i + 1] *= factor;
				formant_fftbuffer[2*i2] *= factor;
				formant_fftbuffer[2*i2 + 1] *= factor;

				i += 1;
			);
			fft_ipermute(formant_fftbuffer, fftsize);
			ifft(formant_fftbuffer, fftsize);

			// Copy to output
			i = 0;
			while (i < formant_buffer_length) (
				i2 = formant_index + i;
				i2 >= formant_buffer_length ? (
					i2 -= formant_buffer_length;
				);
				window_ratio = (i + 0.5)/formant_buffer_length;
				window_value = 0.5 - 0.5*cos(window_ratio*2*$pi);
				window_value /= (1 + 0.999*(window_value - 1));

				formant_output[2*i2] += formant_fftbuffer[2*i]*window_value;
				formant_output[2*i2 + 1] += formant_fftbuffer[2*i + 1]*window_value;
				i += 1;
			);
		);

		spl0 = formant_output[formant_index*2];
		spl1 = formant_output[formant_index*2 + 1];
		formant_output[formant_index*2] = formant_output[formant_index*2 + 1] = 0;
	);

@gfx 240 120

  function dem_min_ui_size(dem_min_ui_width, dem_min_ui_height) (
    (gfx_h <= dem_min_ui_height) ? (
      ui_push_rect(0,0,gfx_w,dem_min_ui_height);
      gfx_h = dem_min_ui_height
    );
  );

  function gfx_ui_automate_slider(slidervar*, new_value) (
    slidervar !== new_value ? (
      slidervar = new_value;
      slider_automate(slidervar);
    );
    new_value;
  );

  function gfx_ui_layout_textnumber(title, value, format) local(h) (
    h = max((ui_height() - 60)/2, ui_height()*0.2);
    ui_split_top(h);
      ui_text(title);
    ui_pop();
    ui_split_bottom(h);
      value = control_hidden_textnumber(value, value*1.00000001, format);
    ui_pop();
    value;
  );

  function gfx_ui_layout_textnumber_up_title(title, value, format) local(h) (
    h = max((ui_height() - 60)/2, ui_height()*0.2);
    ui_split_top(h);
      ui_text(title);
    ui_pop();
    value;
  );

  function gfx_ui_layout_textnumber_up_value(title, value, format) local(h) (
    h = max((ui_height() - 60)/2, ui_height()*0.2);
    ui_split_top(h);
      value = control_hidden_textnumber(value, value*1.00000001, format);
    ui_pop();
    value;
  );

  function gfx_ui_layout_textnumber_down_title(title, value, format) local(h) (
    h = max((ui_height() - 60)/2, ui_height()*0.2);
    ui_split_bottom(h);
      ui_text(title);
    ui_pop();
    value;
  );

  function gfx_ui_layout_textnumber_down_value(title, value, format) local(h) (
    h = max((ui_height() - 60)/2, ui_height()*0.2);
    ui_split_bottom(h);
      value = control_hidden_textnumber(value, value*1.00000001, format);
    ui_pop();
    value;
  );

  function gfx_ui_layout_textnumber_clear(title, value, format) local(h) (
    value;
  );

  function gfx_ui_dial_rounded(dem_theme, slidervar*, low, high, bias, default, step) (
    slidervar != floor(slidervar._ui_gen_float/step + 0.5)*step ? slidervar._ui_gen_float = slidervar;
    slidervar._ui_gen_float = control_dial(dem_theme, slidervar._ui_gen_float, low, high, bias, default);
    gfx_ui_automate_slider(slidervar, floor(slidervar._ui_gen_float/step + 0.5)*step);
  );

  function gfx_ui_layout_text(title, text) local(h) (
    h = max((ui_height() - 60)/2, ui_height()*0.2);
    ui_split_top(h);
      ui_text(title);
    ui_pop();
    ui_split_bottom(h);
      ui_text(text);
    ui_pop();
  );

  function gfx_ui_layout_title(title) (
    gfx_ui_layout_text(title, "");
  );

  function gfx_ui_radio_option(value, optionValue, optionText) (
    ui_align(0.1, 0.5);
    ui_split_left(30);
      value = control_radio(value, optionValue);
    ui_pop();
    ui_click() ? value = optionValue;
    ui_text(optionText);
    value;
  );

  function dem_mcp_ui() (
    control_start("main", "bitmap-simple", 0);
    ui_screen() === "main" ? (
      ui_split_leftratio(2/5);
					gfx_ui_automate_slider(correction_semitones_global, gfx_ui_layout_textnumber_down_value("Pitch", correction_semitones_global, "%i st"));
					gfx_ui_dial_rounded(8,correction_semitones_global, -12, 12, 0, 0, 1);
      ui_pop();
      ui_split_leftratio(1/3);
					gfx_ui_automate_slider(tonality_limit, gfx_ui_layout_textnumber_clear("Tonality Limit", tonality_limit, "%.2f"));
					gfx_ui_dial_rounded(9,tonality_limit, 0, 1, 0, 0.2, 0.01);
      ui_pop();
      ui_split_leftratio(1);
					gfx_ui_automate_slider(formant_shift_semitones, gfx_ui_layout_textnumber_down_value("Form", formant_shift_semitones, "%i st"));
					gfx_ui_dial_rounded(7,formant_shift_semitones, -12, 12, 0, 0, 0.1);
      ui_pop();
    ) : control_system();
  );

  function dem_full_ui() (
	control_start("main", "bitmap-simple", 0);
	ui_screen() === "main" ? (
		ui_split_topratio(1/1); // single row
			ui_split_leftratio(3/3);
				// row 1, group 1
				ui_split_leftratio(1/3);
					gfx_ui_automate_slider(correction_semitones_global, gfx_ui_layout_textnumber("Pitch Shift", correction_semitones_global, "%i st"));
					gfx_ui_dial_rounded(8,correction_semitones_global, -12, 12, 0, 0, 1);
				ui_split_next();
					gfx_ui_automate_slider(formant_shift_semitones, gfx_ui_layout_textnumber("Formant shift", formant_shift_semitones, "%.1f st"));
					gfx_ui_dial_rounded(7,formant_shift_semitones, -12, 12, 0, 0, 0.1);
				ui_split_next();
					gfx_ui_automate_slider(tonality_limit, gfx_ui_layout_textnumber("Tonality Limit", tonality_limit, "%.2f"));
					gfx_ui_dial_rounded(9,tonality_limit, 0, 1, 0, 0.2, 0.01);
				ui_pop();
			ui_pop();
		ui_pop();
	) : control_system();
  );

  dem_initial_gfx_width = 240;  // inital width in @gfx width height
  dem_initial_gfx_height = 120;  // inital height in @gfx width height
  dem_max_mcp_width = 120;   // maximum embedded width
  dem_max_mcp_height = (gfx_w *(dem_initial_gfx_height/dem_initial_gfx_width)); // keep ratio

  gfx_w <= dem_max_mcp_width ? (
    uix_default_fontsize = 7;
    dem_min_ui_size(dem_max_mcp_width, dem_max_mcp_height);
    dem_mcp_ui();

  ) : (
    uix_default_fontsize = 12;
    //dem_min_ui_size(121, 121);
    dem_full_ui();
  );

  ui_interacted() ? needs_slider_update = 1;